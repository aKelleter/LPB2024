<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/x-icon" href="">
    <title>Chargement des ressources: onload et onerror</title>
    <link rel=stylesheet href="../vendors/codemirror/lib/codemirror.css">
    <link rel=stylesheet href="../vendors/codemirror/addon/display/fullscreen.css">
    <link rel=stylesheet href="../vendors/codemirror/theme/eclipse.css">
    <link rel="stylesheet" href="../styles.css">
    <script> let path = "chapter";</script> 
</head>
<body id="top">
    <div class="container">
    <div class="screen">
    <nav></nav>     
    <h1>Chargement des ressources: onload et onerror</h1>
    <hr>     
    <p>
        Le navigateur nous permet de suivre le chargement des ressources externes â€“ scripts, iframes, images, etc.
    </p>
    <p>Il y a deux Ã©vÃ©nements pour cela:</p>
    <ul>
        <li><b>load</b> â€“ l'Ã©lÃ©ment a Ã©tÃ© chargÃ© avec succÃ¨s.</li>
        <li><b>error</b> â€“ une erreur sâ€™est produite.</li>
    </ul>

    <h2>Chargement d'un script</h2>
    <p>
        Disons que nous devons charger un script tiers et appeler une fonction qui y rÃ©side.
    </p>
    <p>Nous pouvons le charger dynamiquement, comme ceci:</p>
    <textarea class="codem">
        let script = document.createElement('script');
        script.src = "my.js";

        document.head.append(script);
    </textarea>
    <p>
        â€¦Mais comment exÃ©cuter la fonction dÃ©clarÃ©e dans ce script? Nous devons attendre que le script se charge pour lâ€™appeler.
    </p>
    <p class="code">        
        <b>Veuillez noter :</b> <br>
        Pour nos propres scripts, nous pourrions utiliser des [modules JavaScript] (info:modules) ici, mais ils ne sont pas largement adoptÃ©s 
        par les bibliothÃ¨ques tierces.
    </p>

    <h2>script.onload</h2>
    <p>Lâ€™assistant principal est lâ€™Ã©vÃ©nement load. Il se dÃ©clenche aprÃ¨s le chargement et lâ€™exÃ©cution du script.</p>
    <p>Par exemple:</p>
    <textarea class="codem">
        let script = document.createElement('script');

        // peut charger n'importe quel script, depuis n'importe quel domaine
        script.src = "https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.3.0/lodash.js"
        document.head.append(script);

        script.onload = function() {
            let ver = _.VERSION;           
            alert( ver ); // affiche la version de la bibliothÃ¨que
        };
    </textarea>
    <a href="tests/test06.html" target="_blank">Demo</a>
    <p>Donc, dans onload, nous pouvons utiliser des variables de script, exÃ©cuter des fonctions, etc.</p>
    <p>â€¦Et si le chargement Ã©chouait? Par exemple, il nâ€™y a pas de tel script (erreur 404) ou le serveur est en panne (indisponible).</p>
   
    <h2>script.onerror</h2>
    <p>
        Les erreurs qui se produisent pendant le chargement du script peuvent Ãªtre suivies dans un Ã©vÃ©nement error.
    </p>
    <p>Par exemple, demandons un script qui nâ€™existe pas:</p>
    <textarea class="codem">
        let script = document.createElement('script');
        script.src = "https://example.com/404.js"; // pas de tel script
        document.head.append(script);

        script.onerror = function() {
            alert("Error loading " + this.src); // Erreur de chargement de https://example.com/404.js
        };
    </textarea>
    <a href="tests/test07.html" target="_blank">Demo</a>
    <p>
        Veuillez noter que nous ne pouvons pas obtenir les dÃ©tails des erreurs HTTP ici. Nous ne savons pas si câ€™Ã©tait une erreur 404 ou 500 
        ou autre chose. Juste que le chargement a Ã©chouÃ©.
    </p>
    <p class="code danger">        
        <b>/!\ Important</b> : <br> <br>

        Les Ã©vÃ©nements <code>onload</code> / <code>onerror</code> ne suivent que le chargement lui-mÃªme.
        Les erreurs qui peuvent survenir lors du traitement et de lâ€™exÃ©cution du script sont hors de portÃ©e de ces Ã©vÃ©nements. <br>
        Câ€™est-Ã -dire: si un script sâ€™est chargÃ© avec succÃ¨s, alors onload se dÃ©clenche, mÃªme sâ€™il contient des erreurs de programmation. <br>
        Pour suivre les erreurs de script, on peut utiliser le gestionnaire global <code>window.onerror</code>.
    </p>

    <h2>Autres ressources</h2>
    <p>
        Les Ã©vÃ©nements <code>load</code> et <code>error</code> fonctionnent aussi pour dâ€™autres ressources, essentiellement pour toute ressource qui 
        a un src externe.
    </p>
    <p>Par exemple:</p>
    <textarea class="codem">
        let img = document.createElement('img');
        img.src = "https://js.cx/clipart/train.gif"; // (*)

        img.onload = function() {
            alert(`Image loaded, size ${img.width}x${img.height}`);
        };

        img.onerror = function() {
            alert("Error occurred while loading image");
        };
    </textarea>
    <p>Il y a cependant deux remarques :</p>
    <a href="tests/test08.html" target="_blank">Demo</a>
    <ul>
        <li>
            La plupart des ressources commencent Ã  se charger lorsquâ€™elles sont ajoutÃ©es au document. Mais &lt;img&gt; est une exception. 
            Elle commence Ã  se charger lorsquâ€™elle obtient un src (*).
        </li>
        <li>
            Pour &lt;iframe&gt;, lâ€™Ã©vÃ©nement iframe.onload se dÃ©clenche lorsque le chargement de lâ€™iframe est terminÃ©, Ã  la fois pour un 
            chargement rÃ©ussi et en cas dâ€™erreur.
        </li>
    </ul>
    <p>Câ€™est pour des raisons historiques.</p>

    <h2>Politique de crossorigin</h2>
    <p>
        Il y a une rÃ¨gle: les scripts dâ€™un site ne peuvent pas accÃ©der au contenu de lâ€™autre site. Donc, par exemple un script 
        sur https://facebook.com ne peut pas lire la boÃ®te aux lettres de lâ€™utilisateur sur https://gmail.com.
    </p>
    <p>
        Ou, pour Ãªtre plus prÃ©cis, une origine (triplet domaine/port/protocole) ne peut pas accÃ©der au contenu Ã  partir dâ€™une autre. 
        Donc, mÃªme si nous avons un sous-domaine, ou juste un autre port, ce sont des origines diffÃ©rentes sans accÃ¨s les uns aux autres. 
    </p>
    <p>Cette rÃ¨gle affecte Ã©galement les ressources dâ€™autres domaines.</p>
    <p>
        Si nous utilisons un script dâ€™un autre domaine et quâ€™il contient une erreur, nous ne pouvons pas obtenir les dÃ©tails de lâ€™erreur.
    </p>
    <p>
        Par exemple, prenons un script error.js qui consiste en un seul (mauvais) appel de fonction:
    </p>
    <textarea class="codem">
        // ğŸ“ error.js
        noSuchFunction();   
    </textarea>
    <p>Maintenant, chargez-le depuis le mÃªme site oÃ¹ il se trouve:</p>
    <textarea class="codem">
        <script>
            window.onerror = function(message, url, line, col, errorObj) {
              alert(`${message}\n${url}, ${line}:${col}`);
            };
        </script>
        <script src="error.js"></script>
    </textarea>
    <a href="tests/test09.html" target="_blank">Demo</a>
    <p>Nous pouvons voir un bon rapport dâ€™erreur, comme ceci:</p>
    <p class="code">
        ReferenceError: noSuchFunction is not defined <br>
        http://127.0.0.1:5501/courses/javascript/v1/09.Chargement-document-ressources/tests/error.js, 1:1
    </p>
    <p>Maintenant, chargeons le mÃªme script Ã  partir dâ€™un autre domaine:</p>
    <textarea class="codem">
        <script>
            window.onerror = function(message, url, line, col, errorObj) {
              alert(`${message}\n${url}, ${line}:${col}`);
            };
        </script>
        <script src="https://cors.javascript.info/article/onload-onerror/crossorigin/error.js"></script>
    </textarea>
    <a href="tests/test10.html" target="_blank">Demo</a>
    <p>Le rapport est diffÃ©rent, comme ceci:</p>
    <p class="code">
        Script error. <br>
        https://cors.javascript.info/article/onload-onerror/crossorigin/error.js, 0:0
    </p>
    <p>
        Les dÃ©tails peuvent varier en fonction du navigateur, mais lâ€™idÃ©e est la mÃªme: toute information sur les Ã©lÃ©ments internes 
        dâ€™un script, y compris les traces de pile dâ€™erreurs, est masquÃ©e. Exactement parce que câ€™est dâ€™un autre domaine.
    </p>
    <p>Pourquoi avons-nous besoin de dÃ©tails dâ€™erreur?</p>
    <p>
        Il existe de nombreux services (et nous pouvons crÃ©er le nÃ´tre) qui Ã©coutent les erreurs globales en utilisant window.onerror, 
        enregistrent les erreurs et fournissent une interface pour y accÃ©der et les analyser. Câ€™est gÃ©nial, car nous pouvons voir de 
        vraies erreurs, dÃ©clenchÃ©es par nos utilisateurs. Mais si un script vient dâ€™une autre origine, alors il nâ€™y a pas beaucoup 
        dâ€™informations sur les erreurs, comme nous venons de le voir.
    </p>
    <p>Une politique dâ€™origine croisÃ©e similaire (CORS) est Ã©galement appliquÃ©e pour dâ€™autres types de ressources.</p>
    <p class="code">
        <b>Pour permettre lâ€™accÃ¨s cross-origin, la balise &lt;script&gt; doit avoir lâ€™attribut crossorigin, et le serveur distant doit 
        fournir des en-tÃªtes spÃ©ciaux.</b>
    </p>
    <p>Il existe trois niveaux dâ€™accÃ¨s cross-origin:</p>
    <ul>
        <li><b>Aucun attribut crossorigin</b> â€“ <span class="danger">accÃ¨s interdit</span>.</li>
        <li>
            <b>crossorigin="anonymous"</b> â€“ <span class="danger">accÃ¨s autorisÃ© si le serveur rÃ©pond avec lâ€™en-tÃªte Access-Control-Allow-Origin avec * ou notre origine</span>. 
            Le navigateur nâ€™envoie pas dâ€™autorisation d'information et de cookies au serveur distant.
        </li>
        <li>
            <b>crossorigin="use-credentials"</b> â€“ <span class="danger">accÃ¨s autorisÃ© si le serveur renvoie lâ€™en-tÃªte Access-Control-Allow-Origin avec notre origine 
            et Access-Control-Allow-Credentials:true</span>. Le navigateur envoie des informations dâ€™autorisation et des cookies au serveur distant.
        </li>
    </ul>
    <p class="code">        
        <b>Veuillez noter</b> : <br>
        Vous pouvez en savoir plus sur lâ€™accÃ¨s cross-origin dans le chapitre Fetch: RequÃªtes Cross-Origin. Il dÃ©crit la mÃ©thode 
        fetch pour les requÃªtes rÃ©seau, mais la politique est exactement la mÃªme.
        Les â€œcookiesâ€ sont hors de notre portÃ©e actuelle, mais vous pouvez les lire dans le chapitre Cookies, 
        document.cookie.
    </p>
    <p>Dans notre cas, nous nâ€™avions aucun attribut crossorigin. Lâ€™accÃ¨s cross-origin Ã©tait donc interdit. Ajoutons-le.</p>
    <p>
        Nous pouvons choisir entre "<em>anonymous</em>" (aucun cookie envoyÃ©, un en-tÃªte cÃ´tÃ© serveur nÃ©cessaire) et "<em>use-credentials</em>" 
        (envoie Ã©galement des cookies, deux en-tÃªtes cÃ´tÃ© serveur nÃ©cessaires).
    </p>
    <p>Si nous ne nous soucions pas des cookies, alors "anonymous" est la voie Ã  suivre:</p>
    <textarea class="codem">
        <script>
            window.onerror = function(message, url, line, col, errorObj) {
              alert(`${message}\n${url}, ${line}:${col}`);
            };
        </script>
        <script crossorigin="anonymous" src="https://cors.javascript.info/article/onload-onerror/crossorigin/error.js"></script>
    </textarea>
    <a href="tests/test11.html" target="_blank">Demo</a>
    <p>
        Maintenant, en supposant que le serveur fournit un en-tÃªte Access-Control-Allow-Origin, tout va 
        bien. Nous avons le rapport dâ€™erreur complet.
    </p>

    <h2>RÃ©sumÃ©</h2>
    <p>
        Les images &lt;img&gt;, les styles externes, les scripts et autres ressources fournissent 
        des Ã©vÃ©nements <code>load</code> et <code>error</code> pour suivre leur chargement:
    </p>
    <ul>
        <li><code>load</code> se dÃ©clenche en cas de chargement rÃ©ussi.</li>
        <li><code>error</code> se dÃ©clenche en cas dâ€™Ã©chec du chargement.</li>
    </ul>
    <p>
        La seule exception est &lt;iframe&gt;: pour des raisons historiques, il dÃ©clenche toujours load,
        pour tout achÃ¨vement de chargement, mÃªme si la page nâ€™est pas trouvÃ©e.
    </p>
    <p>
        Lâ€™Ã©vÃ©nement <code>readystatechange</code> fonctionne Ã©galement pour les ressources, mais est rarement utilisÃ©, 
        car les Ã©vÃ©nements <code>load</code> / <code>error</code> sont plus simples.
    </p>



    </div><!--screen-->
    </div><!--container-->
    <footer></footer>  
    <script src="../javascript.js"></script>
    <script src="../vendors/jquery/jquery.min.js"></script>
    <script src="../vendors/codemirror/lib/codemirror.js"></script>
    <script src="../vendors/codemirror/mode/htmlmixed/htmlmixed.js"></script>
    <script src="../vendors/codemirror/mode/javascript/javascript.js"></script>
    <script src="../vendors/codemirror/mode/css/css.js"></script>
    <script src="../vendors/codemirror/mode/php/php.js"></script>
    <script src="../vendors/codemirror/mode/sql/sql.js"></script>   
    <script src="../vendors/codemirror/addon/edit/matchbrackets.js"></script>
    <script src="../vendors/codemirror/addon/display/fullscreen.js"></script>
    <script src="../app.js"></script>
</body>
</html>